# COMPILER-DESIGNS

#AUTHOR:ADWAITA JADHAV

CODES RELATED TO PRINCIPLES OF COMPILER DESIGN

***************************************************************************************************************************
Title: Lexical analyzer for sample language
Aim:  Generate lexical analyzer for sample language using LEX. 
Objective:
1.	To study lexical analysis phase.
2.	To understand lexical construct of any programming language.
3.	To study various ways of implementing lexical analyzer.
4.	To master LEX utility.
	       
Theory:   Write in brief:
1.	Token in any programming language –
2. Lexeme and input buffer –
3. Use of regular expression (RE) in specifying lexical structure of language –
2.	Format of source specification file ( *.l )

Input: Source specification ( *.l ) file for C language and input file ( *.c ) .
Output: Sequence of tokens generated by lexical analyzer.


***************************************************************************************************************************


Title: Parser for sample language using YACC.
Aim:  Implement calculator using LEX and YACC tool.
	
Objective:  
1.	To understand Yacc Tool.
2.	To study how to use Yacc tool for implementing Parser.
3.	To understand the compilation and execution of *.y file.

Theory:   Write in brief for following:
1.	Introduction to Yacc –
2.	Study of *.y file-
3.	Description of Each Section of *.y file with example-
4.	Description of standard inbuilt variables and functions-
5.	Compilation and Execution Process-

Input:
Output:




***************************************************************************************************************************

Title: Intermediate  code generation for sample language using LEX and YACC.
Aim:  Generate intermediate code in the form of 3 address code (Quadruple implementation) using LEX and YACC.
a.	For arithmetic expression
b.	For any control structure

Objective:  
1.	To understand need for intermediate code.
2.	To study intermediate code generation phase, different forms of intermediate code like 3 address code, syntax tree, postfix notation.
3.	To understand syntax directed translation scheme to avoid need for extra pass.
4.	To get need for type checking.

Theory:   Write in brief for following:
1.	Abstract syntax directed translation scheme-
2.	Quadruples, triples, indirect triples 

Input: LEX and YACC specification files for given programming language constructs, input file consisting of given piece of C program.
Example input: 	A = b+c*d+-p;
Output: ICG in the form of quadruples.
	OP	ARG1	ARG2	RES
UMINUS	P	-	T1
*	C	D	T2
+	B	T2	T3
+	T3	T1	T4
=	A	T4	-


***************************************************************************************************************************

Title: Implementing recursive descent parser for sample language.
    Aim: Implement Recursive Descent parser for given grammar.

Objective:  
1.	To study parsing phase in the compiler.
2.	To study types of parsers – top down and bottom up.
3.	Problems encountered during top down parser.
4.	How to write a top down parser.

Theory:   Write in brief for following:
1.	CFG, non-terminals, terminals, productions, derivation sequence-
2.	Introduction to RDP:

3.	Elimination of Left recursion:
4.	Give Example: 

Input: String satisfying given grammar, string not satisfying given grammar to test error condition.
Output: Success for correct string, Failure for syntactically wrong string.


***************************************************************************************************************************


Title: Generating Abstract Syntax tree using LEX and YACC
Aim: Implement parser with ambiguous CFG that recognize infix expression using LEX and YACC and perform semantic checking and generate syntax tree as output

Objective:  
1.	To study Semantic Analyzer parsing phase.
2.	To understand semantic construct of   programming language.
3.	To get used to parser generator, YACC.
4.	To understanding communication between LEX and YACC.

Theory:   Explain following points in brief:
1.	Use of Context Free Grammar in specifying syntax of programming language, with specific example of C language.
2.	Working of lexical analyzer and parser as co-routines to avoid extra pass-
3.	Format of source specification file  ( *.y ) for YACC –
4.	How tokens separated by lexical analyzer generated using LEX  are made available to parser generated by YACC 
5.	Types of Parser

Input: LEX and YACC source specification files for arithmetic grammar.
Output: Generation of abstract syntax tree.



***************************************************************************************************************************

Aim: Writing a C /C++ program to implement local code optimization techniques like constant folding, copy propagation, common sub-expression elimination(Implementation of DAG algorithm).
Objective:  
1.	To understand the need and importance of code optimization.
2.	To study types of optimization - local and global.
3.	To know implementation of DAG.

Theory:  Write in brief for following points:
1.	What is code optimization-.
2.	Types of code optimization – local and global
3.	Basic block, different local optimization techniques like constant folding, copy propagation, common sub-expression elimination.
4.	Directed acyclic graph – creation and traversal.
5.	Algorithm to generate DAG from quadruples.

Input: Intermediate code in the form of 3 address code (quadruple array).
Output: Modified quadruples by applying above mentioned techniques.



***************************************************************************************************************************
Aim: Write a C program to generate code (in assembly language) using labeled tree.
 
Objective:  
1.	To study code generation phase of compiler.
2.	Observe machine dependency of code generation process.
3.	To study the nature of target machine and nature of target code.

Theory:   Write in brief for following points:
1.	Process of code generation
2.	Problem of register allocation and assignment
3.	Assumptions for code generation.
4.	Labeled tree and conversion to labeled tree.

Input: Intermediate code (for arithmetic expression) in the form of syntax tree.
Output: Assembly code generated for given input.








